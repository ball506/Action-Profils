# -*- coding: utf-8 -*-
"""
Define the APL class to represent and parse a simc profile.

@author: skasch
"""

from collections import OrderedDict

from .actions import ActionList, PrecombatAction
from ..objects.units import Player, Target, Unit
from ..objects.lua import LuaCastable
from .context import Context
from ..abstract.helpers import indent
from ..constants import IGNORED_ACTION_LISTS
from ..database import CLASS_SPECS, TEMPLATES


class APL:
    """
    The main class representing an Action Priority List (or simc profile),
    extracted from its simc string.
    """

    DEFAULT_TEMPLATE = ('{context}'
                        '\n--- ======= ACTION LISTS =======\n'
                        '-- [3] Single Rotation\n'
                        'A[3] = function(icon, isMulti)\n'
                        '    --------------------\n'
                        '    --- ROTATION VAR ---\n'
                        '    --------------------\n'
                        '    local isMoving = A.Player:IsMoving()\n'
                        '    local inCombat = Unit("player"):CombatTime() > 0\n'
                        '    local ShouldStop = Action.ShouldStop()\n'
                        '    local Pull = Action.BossMods_Pulling()\n'
                        '    local unit = "player"\n\n'
                        '    ------------------------------------------------------\n'
                        '    ---------------- ENEMY UNIT ROTATION -----------------\n'
                        '    ------------------------------------------------------\n'
                        '    local function EnemyRotation(unit)\n'
                        '{action_list_names}\n'
                        '{action_lists}\n'
                        '{precombat_call}\n\n'
                        '        -- In Combat\n'
                        '        if inCombat and Unit(unit):IsExists() and not Unit(unit):IsTotem() then\n'
                        '        {main_actions}\n'
                        '        end\n'
                        '    end\n'
                        '\n{set_apl}')

    def __init__(self):
        self.simc_lines = []
        self.player = None
        self.target = Target()
        self.profile_name = ''
        self.parsed = True
        self.apl_simc = ''
        self.show_comments = True
        self.action_lists_simc = OrderedDict()
        self.context = Context()
        LuaCastable.cid = 0

    def hide_simc_comments(self):
        """
        Hide the default commented simc lines to the printed lua code.
        """
        self.show_comments = False

    def set_simc_lines(self, simc_lines):
        """
        Set the simc_lines attribute of the object to the content of the
        variable simc_lines.
        """
        self.simc_lines = [simc_line for simc_line in simc_lines
                           if not simc_line.startswith('#')]
        self.parsed = False

    def read_profile(self, file_path):
        """
        Read a .simc profile file.
        """
        with open(file_path, 'r') as profile:
            self.set_simc_lines([line.strip() for line in profile.readlines()])

    def read_string(self, multiline_simc):
        """
        Read a simc profile from a multiline string.
        """
        self.set_simc_lines(multiline_simc.split('\n'))

    def process_lua(self):
        """
        Parse the profile read from the simc_lines attribute and print the lua
        code generated by the profile.
        """
        self.parse_profile()
        return self.print_lua()

    def export_lua(self, file_path):
        """
        Parse the profile read from the simc_lines attribute and export the lua
        code generated into file_path.
        """
        self.parse_profile()
        with open(file_path, 'w') as lua_file:
            lua_file.write(self.print_lua())

    def parse_profile(self):
        """
        Parse the profile from the simc_lines attribute.
        """
        if not self.parsed:
            for simc in self.simc_lines:
                self.parse_line(simc)
            self.parsed = True

    def parse_action(self, simc):
        """
        Parse a single line from the simc_lines attribute if this line is an
        action and append it in its action_list in action_lists_simc dict.
        """
        equal_index = simc.find('+=')
        equal_len = 2
        if equal_index == -1:
            equal_index = simc.find('=')
            equal_len = 1
        if equal_index == -1:
            return
        action_call = simc[:equal_index]
        action_simc = simc[equal_index + equal_len:]
        if '.' not in action_call:
            self.apl_simc += action_simc
            return
        action_list_name = action_call.split('.')[1]
        if action_list_name not in IGNORED_ACTION_LISTS:
            if action_list_name in self.action_lists_simc:
                self.action_lists_simc[action_list_name] += action_simc
            else:
                self.action_lists_simc[action_list_name] = action_simc

    def precombat_action(self):
        """
        Get the call to precombat actions.
        """
        return PrecombatAction(self)

    def main_action_list(self):
        """
        Get the ActionList object for the main action list.
        """
        return ActionList(self, self.apl_simc, 'APL')

    def action_lists(self):
        """
        Get the list of ActionList objects from action_lists_simc.
        """
        return [ActionList(self, simc, name)
                for name, simc in self.action_lists_simc.items()]

    def parse_line(self, simc):
        """
        Parse a single line in simc_lines.
        """
        if any(simc.startswith(class_) for class_ in CLASS_SPECS):
            class_, profile_name = simc.split('=')
            self.set_player(class_)
            self.set_profile_name(profile_name)
        elif simc.startswith('spec'):
            _, spec = simc.split('=')
            self.player.set_spec(spec)
        elif simc.startswith('level'):
            _, level = simc.split('=')
            self.player.set_level(level)
        elif simc.startswith('race'):
            _, race = simc.split('=')
            self.player.set_race(race)
        elif simc.startswith('actions'):
            self.parse_action(simc)

    def set_profile_name(self, simc):
        """
        Set the profile name.
        """
        self.profile_name = simc.replace('"', '')

    def set_player(self, simc):
        """
        Set a player as the main actor of the APL.
        """
        self.player = Player(simc, self)
        self.context.set_player(self.player)

    def set_target(self, simc):
        """
        Set the target of the main actor of the APL.
        """
        self.target = Target(simc)

    def print_action_list_names(self):
        """
        Print the definition of action list names in local.
        """
        action_list_names_lua = [action_list.name.print_lua()
                                 for action_list in self.action_lists()]
        if len(action_list_names_lua) > 0:
            return indent('local ' + ', '.join(action_list_names_lua))
        return ''

    def print_action_lists_lua(self):
        """
        Print the lua string of the APL.
        """
        return '\n'.join(indent(action_list.print_lua())
                         for action_list in self.action_lists())

    def print_set_apl(self):
        """
        Print the call to SetAPL to set the APL into HR.
        """
        class_simc = self.player.class_.simc
        spec_simc = self.player.spec.simc
        apl_id = CLASS_SPECS.get(class_simc, {}).get(spec_simc, 0)
        return ('    -- End on EnemyRotation()\n\n'	
        '    -- Defensive\n'
        '    --local SelfDefensive = SelfDefensives()\n'
        '    if SelfDefensive then \n'
        '        return SelfDefensive:Show(icon)\n'
        '    end \n\n'

        '    -- Mouseover\n'     
        '    if A.IsUnitEnemy("mouseover") then\n' 
        '        unit = "mouseover"\n'
        '        if EnemyRotation(unit) then \n'
        '            return true \n'
        '        end \n'
        '    end \n\n'
    
        '    -- Target  \n'           
        '    if A.IsUnitEnemy("target") then \n'
        '        unit = "target"\n'
        
        '        if EnemyRotation(unit) then \n'
        '            return true\n' 
        '        end \n\n'
        '    end\n'
        'end\n'
        '-- Finished\n\n'
        '-- [4] AoE Rotation\n'
        'A[4] = function(icon)\n'
        '    return A[3](icon, true)\n'
        'end\n '
        '-- [5] Trinket Rotation\n'
        '-- No specialization trinket actions \n'
        '-- Passive \n'
        '--[[local function FreezingTrapUsedByEnemy()\n'
        '    if     UnitCooldown:GetCooldown("arena", 3355) > UnitCooldown:GetMaxDuration("arena", 3355) - 2 and\n' 
        '    UnitCooldown:IsSpellInFly("arena", 3355) and \n'
        '    Unit("player"):GetDR("incapacitate") >= 50 \n'
        '    then \n'
        '        local Caster = UnitCooldown:GetUnitID("arena", 3355)\n'
        '        if Caster and Unit(Caster):GetRange() <= 40 then \n'
        '            return true \n'
        '        end \n'
        '    end \n'
        'end \n'

        'local function ArenaRotation(icon, unit)\n'
        '    if A.IsInPvP and (A.Zone == "pvp" or A.Zone == "arena") and not Player:IsStealthed() and not Player:IsMounted() then\n'             
        '        -- Note: "arena1" is just identification of meta 6\n'
        '        if unit == "arena1" and (Unit("player"):GetDMG() == 0 or not Unit("player"):IsFocused("DAMAGER")) then \n'                 
        '            -- Reflect Casting BreakAble CC\n'
        '            if A.NetherWard:IsReady() and A.NetherWard:IsSpellLearned() and Action.ShouldReflect(EnemyTeam()) and EnemyTeam():IsCastingBreakAble(0.25) then \n'
        '                return A.NetherWard:Show(icon)\n'
        '            end \n'		
        '        end\n'                        
        '    end \n'
        'end \n'

        'local function PartyRotation(unit)\n'
        '    if (unit == "party1" and not A.GetToggle(2, "PartyUnits")[1]) or (unit == "party2" and not A.GetToggle(2, "PartyUnits")[2]) then \n'
        '        return false \n'
        '    end\n\n'
        '  	-- SingeMagic\n'
        '    if A.SingeMagic:IsCastable() and A.SingeMagic:AbsentImun(unit, Temp.TotalAndMag) and IsSchoolFree() and Action.AuraIsValid(unit, "UseDispel", "Magic") and not Unit(unit):InLOS() then\n'
        '        return A.SingeMagic:Show(icon)\n'
        '    end\n'		

        'end \n\n'
        'A[6] = function(icon)\n'    
        '    return ArenaRotation(icon, "arena1")\n'
        'end\n\n'
        'A[7] = function(icon)\n'
        '    local Party = PartyRotation("party1") \n'
        '    if Party then \n'
        '        return Party:Show(icon)\n'
        '    end \n'
    
        '    return ArenaRotation(icon, "arena2")\n'
        'end\n\n'
        'A[8] = function(icon)\n'
        '    local Party = PartyRotation("party2") \n'
        '    if Party then \n'
        '        return Party:Show(icon)\n'
        '    end     \n'
        '    return ArenaRotation(icon, "arena3")\n'
        'end]]--\n\n'
                )

    def template(self):
        return TEMPLATES.get(self.player.class_.simc+self.player.spec.simc, self.DEFAULT_TEMPLATE)

    def print_lua(self):
        """
        Print the lua string representing the action list.
        """
        function_name = self.main_action_list().name.lua_name()
        action_list_names = self.print_action_list_names()
        action_lists = self.print_action_lists_lua()
        precombat_call = self.precombat_action().print_lua()
        main_actions = self.main_action_list().print_actions_lua()
        context = self.context.print_lua()
        set_apl = self.print_set_apl()
        return self.template().format(
            context=context,
            function_name=function_name,
            action_list_names=indent(action_list_names),
            action_lists=indent(action_lists),
            precombat_call=precombat_call,
            main_actions=indent(indent(main_actions)),
            set_apl=set_apl
        )
